<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on No more than One Hundred and Sixty Six</title>
		<link>https://ldipotetjob.github.io/posts/</link>
		<description>Recent content in Posts on No more than One Hundred and Sixty Six</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Mon, 09 Sep 2019 11:36:33 +0800</lastBuildDate>
		<atom:link href="https://ldipotetjob.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Pattern Matching-I</title>
			<link>https://ldipotetjob.github.io/posts/pattern_matching9-14/</link>
			<pubDate>Mon, 09 Sep 2019 11:36:33 +0800</pubDate>
			
			<guid>https://ldipotetjob.github.io/posts/pattern_matching9-14/</guid>
			<description>Pattern matching specification
This post covers the following patern matching specifications:
 Pattern Sequences. Infix Operation Patterns. Pattern Alternatives. Irrefutable Patterns.  For previuos kinds of Pattern matching specifications review this link
 Pattern Sequences:
 SimplePattern ::= StableId ‘(’ [Patterns ‘,’] [varid ‘@’] ‘_’ ‘*’ ‘)’
 val testList:List[Int] = List(1,1) testList match { case List(1, _*) =&amp;gt; s&amp;#34;hello $testList&amp;#34; case _ =&amp;gt; &amp;#34; nothing match&amp;#34; } // res23: String = hello List(1, 1)  val testListbinding:List[Int] = List(1,1) testList match { case testList@List(1, _*) =&amp;gt; &amp;#34;a list beginning with 1, binding&amp;#34; case _ =&amp;gt; &amp;#34; nothing match binding&amp;#34; } // testListbinding: List[Int] = List(1, 1) // res24: String = a list beginning with 1, binding  testList match { case x @ List(1, _*) =&amp;gt; s&amp;#34;$x&amp;#34; case _ =&amp;gt; &amp;#34; nothing match binding&amp;#34; } // res25: String = List(1, 1) Infix Operation Patterns:</description>
			<content type="html"><![CDATA[<p><a href="https://www.scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html">Pattern matching specification</a></p>
<p>This post covers the following patern matching specifications:</p>
<ol>
<li>Pattern Sequences.</li>
<li>Infix Operation Patterns.</li>
<li>Pattern Alternatives.</li>
<li>Irrefutable Patterns.</li>
</ol>
<p><a href="https://ldipotetjob.github.io/posts/pattern_matching1-8/">For previuos kinds of Pattern matching specifications review this link</a></p>
<hr>
<p><a href="https://www.scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html#pattern-sequences">Pattern Sequences:</a></p>
<blockquote>
<p>SimplePattern ::= StableId ‘(’ [Patterns ‘,’] [varid ‘@’] ‘_’ ‘*’ ‘)’</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">val</span> <span class="nx">testList</span><span class="o">:</span><span class="nx">List</span><span class="p">[</span><span class="nx">Int</span><span class="p">]</span> <span class="o">=</span> <span class="nx">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="nx">testList</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">_</span><span class="o">*</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">s</span><span class="s2">&#34;hello $testList&#34;</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="s2">&#34; nothing match&#34;</span>
<span class="p">}</span>

<span class="c1">// res23: String = hello List(1, 1)
</span><span class="c1"></span>
<span class="nx">val</span> <span class="nx">testListbinding</span><span class="o">:</span><span class="nx">List</span><span class="p">[</span><span class="nx">Int</span><span class="p">]</span> <span class="o">=</span> <span class="nx">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="nx">testList</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">testList</span><span class="err">@</span><span class="nx">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">_</span><span class="o">*</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="s2">&#34;a list beginning with 1, binding&#34;</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="s2">&#34; nothing match  binding&#34;</span>
<span class="p">}</span>

<span class="c1">// testListbinding: List[Int] = List(1, 1)
</span><span class="c1">// res24: String = a list beginning with 1, binding
</span><span class="c1"></span>
<span class="nx">testList</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">x</span> <span class="err">@</span> <span class="nx">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">_</span><span class="o">*</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">s</span><span class="s2">&#34;$x&#34;</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="s2">&#34; nothing match  binding&#34;</span>
<span class="p">}</span>

<span class="c1">// res25: String = List(1, 1)
</span></code></pre></div><p><a href="https://www.scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html#infix-operation-patterns">Infix Operation Patterns:</a></p>
<blockquote>
<p>Pattern3  ::=  SimplePattern {id [nl] SimplePattern}</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript">
<span class="cm">/**
</span><span class="cm">  *   Infix operator is a shorthand for the constructor or extractor pattern
</span><span class="cm">  *   examples infix operator:
</span><span class="cm">  *   
</span><span class="cm">  *   infix operator for syntactic sugar
</span><span class="cm">  *   ref: https://docs.scala-lang.org/tour/operators.html.
</span><span class="cm">  *   
</span><span class="cm">  *   examples of infix operators:
</span><span class="cm">  *   +, -, *, ++,::,:+, etc and are just methods.
</span><span class="cm">  *
</span><span class="cm">  */</span>

<span class="c1">//normal notation
</span><span class="c1"></span><span class="mf">10.</span><span class="o">+</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>

<span class="c1">//infix notation
</span><span class="c1"></span><span class="mi">10</span> <span class="o">+</span> <span class="mi">20</span>

<span class="k">case</span> <span class="kr">class</span> <span class="nx">Vec</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="nx">Double</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">Double</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">def</span> <span class="o">+</span><span class="p">(</span><span class="nx">that</span><span class="o">:</span> <span class="nx">Vec</span><span class="p">)</span> <span class="o">=</span> <span class="nx">Vec</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">that</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">that</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">val</span> <span class="nx">vector1</span> <span class="o">=</span> <span class="nx">Vec</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="nx">val</span> <span class="nx">vector2</span> <span class="o">=</span> <span class="nx">Vec</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>

<span class="c1">//normal notation
</span><span class="c1"></span><span class="nx">val</span> <span class="nx">vector3</span> <span class="o">=</span> <span class="nx">vector1</span><span class="p">.</span><span class="o">+</span><span class="p">(</span><span class="nx">vector2</span><span class="p">)</span>
<span class="nx">vector3</span><span class="p">.</span><span class="nx">x</span>  <span class="c1">// 3.0
</span><span class="c1"></span><span class="nx">vector3</span><span class="p">.</span><span class="nx">y</span>  <span class="c1">// 3.0
</span><span class="c1"></span>
<span class="c1">//infix notation
</span><span class="c1"></span><span class="nx">val</span> <span class="nx">vector4</span> <span class="o">=</span> <span class="nx">vector1</span> <span class="o">+</span> <span class="nx">vector2</span>
<span class="nx">vector4</span><span class="p">.</span><span class="nx">x</span>  <span class="c1">// 3.0
</span><span class="c1"></span><span class="nx">vector4</span><span class="p">.</span><span class="nx">y</span>  <span class="c1">// 3.0
</span><span class="c1"></span>
<span class="c1">//::
</span><span class="c1"></span><span class="nx">val</span> <span class="nx">xs</span><span class="o">:</span><span class="nx">List</span><span class="p">[</span><span class="nx">Int</span><span class="p">]</span> <span class="o">=</span> <span class="nx">List</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>

<span class="nx">xs</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">first</span> <span class="o">::</span> <span class="nx">second</span> <span class="o">::</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="nx">s</span><span class="s2">&#34;the first element: $first and the second: $second&#34;</span> <span class="p">)</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>

<span class="c1">// the first element: 20 and the second: 2
</span><span class="c1">// res33: AnyVal = ()
</span><span class="c1"></span>
<span class="nx">xs</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">rest</span> <span class="o">+:</span> <span class="nx">tail</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="nx">s</span><span class="s2">&#34;tail elements: $tail&#34;</span> <span class="p">)</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>

<span class="c1">// tail elements: List(2, 3, 4) 
</span><span class="c1">// res34: AnyVal = ()
</span><span class="c1"></span>

<span class="cm">/**
</span><span class="cm">  *   infix notation like tuples
</span><span class="cm">  *   remember e(p1, p2), where e is the extractor and p1 and p2
</span><span class="cm">  *   
</span><span class="cm">  *   x(𝑞1,𝑝1) were X is the extractor and q1 and p1 operand (only two operands)
</span><span class="cm">  *
</span><span class="cm">  */</span>

<span class="k">case</span> <span class="kr">class</span> <span class="nx">Person</span><span class="p">[</span><span class="nx">A</span><span class="p">,</span><span class="nx">B</span><span class="p">](</span><span class="nx">name</span><span class="o">:</span> <span class="nx">A</span><span class="p">,</span> <span class="nx">age</span><span class="o">:</span> <span class="nx">B</span><span class="p">)</span>

<span class="nx">val</span> <span class="nx">student</span><span class="o">:</span> <span class="nx">Person</span><span class="p">[</span><span class="nb">String</span><span class="p">,</span><span class="nx">Int</span><span class="p">]</span> <span class="o">=</span> <span class="nx">Person</span><span class="p">(</span><span class="s2">&#34;Luis&#34;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>

<span class="nx">val</span> <span class="nx">student1</span><span class="o">:</span> <span class="nx">Person</span><span class="p">[</span><span class="nb">String</span><span class="p">,</span><span class="nx">Int</span><span class="p">]</span> <span class="o">=</span> <span class="nx">Person</span><span class="p">(</span><span class="s2">&#34;Peter&#34;</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>

<span class="nx">Seq</span><span class="p">(</span><span class="nx">student</span><span class="p">,</span> <span class="nx">student1</span><span class="p">)</span> <span class="nx">foreach</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">name</span> <span class="nx">Person</span> <span class="nx">age</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="nx">s</span><span class="s2">&#34;$name with $age&#34;</span><span class="p">)</span>
  <span class="k">case</span> <span class="nx">currentstudent</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="nx">s</span><span class="s2">&#34;Unknown: $currentstudent&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// student: Person[String,Int] = Person(Luis,20)
</span><span class="c1"></span>
<span class="c1">// student1: Person[String,Int] = Person(Peter,23)
</span><span class="c1"></span>
<span class="c1">// Luis with 20
</span><span class="c1">// Peter with 23
</span><span class="c1">// res36: Unit = ()
</span><span class="c1"></span>
</code></pre></div><p><a href="https://www.scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html#pattern-alternatives">Pattern Alternatives:</a></p>
<blockquote>
<p>Pattern   ::=  Pattern1 { ‘|’ Pattern1 }</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">def</span> <span class="nx">matchDifferentPatterns</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="nx">Any</span><span class="p">)</span><span class="o">:</span> <span class="nx">Any</span> <span class="o">=</span> <span class="nx">x</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="p">=&gt;</span> <span class="s2">&#34;one or two&#34;</span>
  <span class="k">case</span> <span class="s2">&#34;two&#34;</span> <span class="p">=&gt;</span> <span class="mi">2</span>
  <span class="k">case</span> <span class="mi">3</span> <span class="o">|</span> <span class="mi">4</span> <span class="p">=&gt;</span> <span class="s2">&#34;three or four&#34;</span>  
  <span class="k">case</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">Int</span> <span class="p">=&gt;</span> <span class="s2">&#34;scala.Int&#34;</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="s2">&#34;many&#34;</span>
<span class="p">}</span>

<span class="nx">matchDifferentPatterns</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// res37: Any = one or two
</span><span class="c1"></span>
<span class="nx">matchDifferentPatterns</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// res38: Any = one or two
</span><span class="c1"></span>
<span class="nx">matchDifferentPatterns</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// res39: Any = three or four
</span><span class="c1"></span>
<span class="nx">matchDifferentPatterns</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// res40: Any = three or four
</span></code></pre></div><p><a href="https://www.scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html#irrefutable-patterns">Irrefutable Patterns:</a></p>
<blockquote>
<p>SimplePattern   ::=  StableId</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">//𝑝 is a typed pattern 𝑥:𝑇′, and 𝑇&lt;:𝑇′,
</span><span class="c1"></span><span class="kr">abstract</span> <span class="kr">class</span> <span class="nx">Device</span>
<span class="k">case</span> <span class="kr">class</span> <span class="nx">Phone</span><span class="p">(</span><span class="nx">model</span><span class="o">:</span> <span class="nb">String</span><span class="p">)</span> <span class="kr">extends</span> <span class="nx">Device</span> <span class="p">{</span>
  <span class="nx">def</span> <span class="nx">screenOff</span> <span class="o">=</span> <span class="s2">&#34;Turning screen off&#34;</span>
<span class="p">}</span>
<span class="k">case</span> <span class="kr">class</span> <span class="nx">Computer</span><span class="p">(</span><span class="nx">model</span><span class="o">:</span> <span class="nb">String</span><span class="p">)</span> <span class="kr">extends</span> <span class="nx">Device</span> <span class="p">{</span>
  <span class="nx">def</span> <span class="nx">screenSaverOn</span> <span class="o">=</span> <span class="s2">&#34;Turning screen saver on...&#34;</span>
<span class="p">}</span>

<span class="nx">def</span> <span class="nx">goIdle</span><span class="p">(</span><span class="nx">device</span><span class="o">:</span> <span class="nx">Device</span><span class="p">)</span> <span class="o">=</span> <span class="nx">device</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">p</span><span class="o">:</span> <span class="nx">Phone</span> <span class="p">=&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">screenOff</span>
  <span class="k">case</span> <span class="nx">c</span><span class="o">:</span> <span class="nx">Computer</span> <span class="p">=&gt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">screenSaverOn</span>
<span class="p">}</span>


<span class="c1">//𝑝 is a constructor pattern 𝑐(𝑝1,…,𝑝𝑛)
</span><span class="c1"></span>
<span class="nx">sealed</span> <span class="kr">abstract</span> <span class="kr">class</span> <span class="nx">Furniture</span>
<span class="k">case</span> <span class="kr">class</span> <span class="nx">Couch</span><span class="p">()</span> <span class="kr">extends</span> <span class="nx">Furniture</span>
<span class="k">case</span> <span class="kr">class</span> <span class="nx">Chair</span><span class="p">()</span> <span class="kr">extends</span> <span class="nx">Furniture</span>

<span class="nx">def</span> <span class="nx">findPlaceToSit</span><span class="p">(</span><span class="nx">piece</span><span class="o">:</span> <span class="nx">Furniture</span><span class="p">)</span><span class="o">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nx">piece</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">a</span><span class="o">:</span> <span class="nx">Couch</span> <span class="p">=&gt;</span> <span class="s2">&#34;Lie on the couch&#34;</span>
  <span class="k">case</span> <span class="nx">b</span><span class="o">:</span> <span class="nx">Chair</span> <span class="p">=&gt;</span> <span class="s2">&#34;Sit on the chair&#34;</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Pattern Matching-II</title>
			<link>https://ldipotetjob.github.io/posts/pattern_matching15-17/</link>
			<pubDate>Mon, 09 Sep 2019 11:36:33 +0800</pubDate>
			
			<guid>https://ldipotetjob.github.io/posts/pattern_matching15-17/</guid>
			<description>Pattern matching specification
This post covers the following patern matching specifications:
 Pattern Sequences. Infix Operation Patterns. Pattern Alternatives. Irrefutable Patterns.  For previuos kinds of Pattern matching specifications review this link
 Pattern Sequences:
 SimplePattern ::= StableId ‘(’ [Patterns ‘,’] [varid ‘@’] ‘_’ ‘*’ ‘)’
 val testList:List[Int] = List(1,1) testList match { case List(1, _*) =&amp;gt; s&amp;#34;hello $testList&amp;#34; case _ =&amp;gt; &amp;#34; nothing match&amp;#34; } // res23: String = hello List(1, 1)  val testListbinding:List[Int] = List(1,1) testList match { case testList@List(1, _*) =&amp;gt; &amp;#34;a list beginning with 1, binding&amp;#34; case _ =&amp;gt; &amp;#34; nothing match binding&amp;#34; } // testListbinding: List[Int] = List(1, 1) // res24: String = a list beginning with 1, binding  testList match { case x @ List(1, _*) =&amp;gt; s&amp;#34;$x&amp;#34; case _ =&amp;gt; &amp;#34; nothing match binding&amp;#34; } // res25: String = List(1, 1) Infix Operation Patterns:</description>
			<content type="html"><![CDATA[<p><a href="https://www.scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html">Pattern matching specification</a></p>
<p>This post covers the following patern matching specifications:</p>
<ol>
<li>Pattern Sequences.</li>
<li>Infix Operation Patterns.</li>
<li>Pattern Alternatives.</li>
<li>Irrefutable Patterns.</li>
</ol>
<p><a href="https://ldipotetjob.github.io/posts/pattern_matching1-8/">For previuos kinds of Pattern matching specifications review this link</a></p>
<hr>
<p><a href="https://www.scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html#pattern-sequences">Pattern Sequences:</a></p>
<blockquote>
<p>SimplePattern ::= StableId ‘(’ [Patterns ‘,’] [varid ‘@’] ‘_’ ‘*’ ‘)’</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">val</span> <span class="nx">testList</span><span class="o">:</span><span class="nx">List</span><span class="p">[</span><span class="nx">Int</span><span class="p">]</span> <span class="o">=</span> <span class="nx">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="nx">testList</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">_</span><span class="o">*</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">s</span><span class="s2">&#34;hello $testList&#34;</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="s2">&#34; nothing match&#34;</span>
<span class="p">}</span>

<span class="c1">// res23: String = hello List(1, 1)
</span><span class="c1"></span>
<span class="nx">val</span> <span class="nx">testListbinding</span><span class="o">:</span><span class="nx">List</span><span class="p">[</span><span class="nx">Int</span><span class="p">]</span> <span class="o">=</span> <span class="nx">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="nx">testList</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">testList</span><span class="err">@</span><span class="nx">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">_</span><span class="o">*</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="s2">&#34;a list beginning with 1, binding&#34;</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="s2">&#34; nothing match  binding&#34;</span>
<span class="p">}</span>

<span class="c1">// testListbinding: List[Int] = List(1, 1)
</span><span class="c1">// res24: String = a list beginning with 1, binding
</span><span class="c1"></span>
<span class="nx">testList</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">x</span> <span class="err">@</span> <span class="nx">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">_</span><span class="o">*</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">s</span><span class="s2">&#34;$x&#34;</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="s2">&#34; nothing match  binding&#34;</span>
<span class="p">}</span>

<span class="c1">// res25: String = List(1, 1)
</span></code></pre></div><p><a href="https://www.scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html#infix-operation-patterns">Infix Operation Patterns:</a></p>
<blockquote>
<p>Pattern3  ::=  SimplePattern {id [nl] SimplePattern}</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript">
<span class="cm">/**
</span><span class="cm">  *   Infix operator is a shorthand for the constructor or extractor pattern
</span><span class="cm">  *   examples infix operator:
</span><span class="cm">  *   
</span><span class="cm">  *   infix operator for syntactic sugar
</span><span class="cm">  *   ref: https://docs.scala-lang.org/tour/operators.html.
</span><span class="cm">  *   
</span><span class="cm">  *   examples of infix operators:
</span><span class="cm">  *   +, -, *, ++,::,:+, etc and are just methods.
</span><span class="cm">  *
</span><span class="cm">  */</span>

<span class="c1">//normal notation
</span><span class="c1"></span><span class="mf">10.</span><span class="o">+</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>

<span class="c1">//infix notation
</span><span class="c1"></span><span class="mi">10</span> <span class="o">+</span> <span class="mi">20</span>

<span class="k">case</span> <span class="kr">class</span> <span class="nx">Vec</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="nx">Double</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">Double</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">def</span> <span class="o">+</span><span class="p">(</span><span class="nx">that</span><span class="o">:</span> <span class="nx">Vec</span><span class="p">)</span> <span class="o">=</span> <span class="nx">Vec</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">that</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">that</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">val</span> <span class="nx">vector1</span> <span class="o">=</span> <span class="nx">Vec</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="nx">val</span> <span class="nx">vector2</span> <span class="o">=</span> <span class="nx">Vec</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>

<span class="c1">//normal notation
</span><span class="c1"></span><span class="nx">val</span> <span class="nx">vector3</span> <span class="o">=</span> <span class="nx">vector1</span><span class="p">.</span><span class="o">+</span><span class="p">(</span><span class="nx">vector2</span><span class="p">)</span>
<span class="nx">vector3</span><span class="p">.</span><span class="nx">x</span>  <span class="c1">// 3.0
</span><span class="c1"></span><span class="nx">vector3</span><span class="p">.</span><span class="nx">y</span>  <span class="c1">// 3.0
</span><span class="c1"></span>
<span class="c1">//infix notation
</span><span class="c1"></span><span class="nx">val</span> <span class="nx">vector4</span> <span class="o">=</span> <span class="nx">vector1</span> <span class="o">+</span> <span class="nx">vector2</span>
<span class="nx">vector4</span><span class="p">.</span><span class="nx">x</span>  <span class="c1">// 3.0
</span><span class="c1"></span><span class="nx">vector4</span><span class="p">.</span><span class="nx">y</span>  <span class="c1">// 3.0
</span><span class="c1"></span>
<span class="c1">//::
</span><span class="c1"></span><span class="nx">val</span> <span class="nx">xs</span><span class="o">:</span><span class="nx">List</span><span class="p">[</span><span class="nx">Int</span><span class="p">]</span> <span class="o">=</span> <span class="nx">List</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>

<span class="nx">xs</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">first</span> <span class="o">::</span> <span class="nx">second</span> <span class="o">::</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="nx">s</span><span class="s2">&#34;the first element: $first and the second: $second&#34;</span> <span class="p">)</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>

<span class="c1">// the first element: 20 and the second: 2
</span><span class="c1">// res33: AnyVal = ()
</span><span class="c1"></span>
<span class="nx">xs</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">rest</span> <span class="o">+:</span> <span class="nx">tail</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="nx">s</span><span class="s2">&#34;tail elements: $tail&#34;</span> <span class="p">)</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>

<span class="c1">// tail elements: List(2, 3, 4) 
</span><span class="c1">// res34: AnyVal = ()
</span><span class="c1"></span>

<span class="cm">/**
</span><span class="cm">  *   infix notation like tuples
</span><span class="cm">  *   remember e(p1, p2), where e is the extractor and p1 and p2
</span><span class="cm">  *   
</span><span class="cm">  *   x(𝑞1,𝑝1) were X is the extractor and q1 and p1 operand (only two operands)
</span><span class="cm">  *
</span><span class="cm">  */</span>

<span class="k">case</span> <span class="kr">class</span> <span class="nx">Person</span><span class="p">[</span><span class="nx">A</span><span class="p">,</span><span class="nx">B</span><span class="p">](</span><span class="nx">name</span><span class="o">:</span> <span class="nx">A</span><span class="p">,</span> <span class="nx">age</span><span class="o">:</span> <span class="nx">B</span><span class="p">)</span>

<span class="nx">val</span> <span class="nx">student</span><span class="o">:</span> <span class="nx">Person</span><span class="p">[</span><span class="nb">String</span><span class="p">,</span><span class="nx">Int</span><span class="p">]</span> <span class="o">=</span> <span class="nx">Person</span><span class="p">(</span><span class="s2">&#34;Luis&#34;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>

<span class="nx">val</span> <span class="nx">student1</span><span class="o">:</span> <span class="nx">Person</span><span class="p">[</span><span class="nb">String</span><span class="p">,</span><span class="nx">Int</span><span class="p">]</span> <span class="o">=</span> <span class="nx">Person</span><span class="p">(</span><span class="s2">&#34;Peter&#34;</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>

<span class="nx">Seq</span><span class="p">(</span><span class="nx">student</span><span class="p">,</span> <span class="nx">student1</span><span class="p">)</span> <span class="nx">foreach</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">name</span> <span class="nx">Person</span> <span class="nx">age</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="nx">s</span><span class="s2">&#34;$name with $age&#34;</span><span class="p">)</span>
  <span class="k">case</span> <span class="nx">currentstudent</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="nx">s</span><span class="s2">&#34;Unknown: $currentstudent&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// student: Person[String,Int] = Person(Luis,20)
</span><span class="c1"></span>
<span class="c1">// student1: Person[String,Int] = Person(Peter,23)
</span><span class="c1"></span>
<span class="c1">// Luis with 20
</span><span class="c1">// Peter with 23
</span><span class="c1">// res36: Unit = ()
</span><span class="c1"></span>
</code></pre></div><p><a href="https://www.scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html#pattern-alternatives">Pattern Alternatives:</a></p>
<blockquote>
<p>Pattern   ::=  Pattern1 { ‘|’ Pattern1 }</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">def</span> <span class="nx">matchDifferentPatterns</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="nx">Any</span><span class="p">)</span><span class="o">:</span> <span class="nx">Any</span> <span class="o">=</span> <span class="nx">x</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="p">=&gt;</span> <span class="s2">&#34;one or two&#34;</span>
  <span class="k">case</span> <span class="s2">&#34;two&#34;</span> <span class="p">=&gt;</span> <span class="mi">2</span>
  <span class="k">case</span> <span class="mi">3</span> <span class="o">|</span> <span class="mi">4</span> <span class="p">=&gt;</span> <span class="s2">&#34;three or four&#34;</span>  
  <span class="k">case</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">Int</span> <span class="p">=&gt;</span> <span class="s2">&#34;scala.Int&#34;</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="s2">&#34;many&#34;</span>
<span class="p">}</span>

<span class="nx">matchDifferentPatterns</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// res37: Any = one or two
</span><span class="c1"></span>
<span class="nx">matchDifferentPatterns</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// res38: Any = one or two
</span><span class="c1"></span>
<span class="nx">matchDifferentPatterns</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">// res39: Any = three or four
</span><span class="c1"></span>
<span class="nx">matchDifferentPatterns</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// res40: Any = three or four
</span></code></pre></div><p><a href="https://www.scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html#irrefutable-patterns">Irrefutable Patterns:</a></p>
<blockquote>
<p>SimplePattern   ::=  StableId</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">//𝑝 is a typed pattern 𝑥:𝑇′, and 𝑇&lt;:𝑇′,
</span><span class="c1"></span><span class="kr">abstract</span> <span class="kr">class</span> <span class="nx">Device</span>
<span class="k">case</span> <span class="kr">class</span> <span class="nx">Phone</span><span class="p">(</span><span class="nx">model</span><span class="o">:</span> <span class="nb">String</span><span class="p">)</span> <span class="kr">extends</span> <span class="nx">Device</span> <span class="p">{</span>
  <span class="nx">def</span> <span class="nx">screenOff</span> <span class="o">=</span> <span class="s2">&#34;Turning screen off&#34;</span>
<span class="p">}</span>
<span class="k">case</span> <span class="kr">class</span> <span class="nx">Computer</span><span class="p">(</span><span class="nx">model</span><span class="o">:</span> <span class="nb">String</span><span class="p">)</span> <span class="kr">extends</span> <span class="nx">Device</span> <span class="p">{</span>
  <span class="nx">def</span> <span class="nx">screenSaverOn</span> <span class="o">=</span> <span class="s2">&#34;Turning screen saver on...&#34;</span>
<span class="p">}</span>

<span class="nx">def</span> <span class="nx">goIdle</span><span class="p">(</span><span class="nx">device</span><span class="o">:</span> <span class="nx">Device</span><span class="p">)</span> <span class="o">=</span> <span class="nx">device</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">p</span><span class="o">:</span> <span class="nx">Phone</span> <span class="p">=&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">screenOff</span>
  <span class="k">case</span> <span class="nx">c</span><span class="o">:</span> <span class="nx">Computer</span> <span class="p">=&gt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">screenSaverOn</span>
<span class="p">}</span>


<span class="c1">//𝑝 is a constructor pattern 𝑐(𝑝1,…,𝑝𝑛)
</span><span class="c1"></span>
<span class="nx">sealed</span> <span class="kr">abstract</span> <span class="kr">class</span> <span class="nx">Furniture</span>
<span class="k">case</span> <span class="kr">class</span> <span class="nx">Couch</span><span class="p">()</span> <span class="kr">extends</span> <span class="nx">Furniture</span>
<span class="k">case</span> <span class="kr">class</span> <span class="nx">Chair</span><span class="p">()</span> <span class="kr">extends</span> <span class="nx">Furniture</span>

<span class="nx">def</span> <span class="nx">findPlaceToSit</span><span class="p">(</span><span class="nx">piece</span><span class="o">:</span> <span class="nx">Furniture</span><span class="p">)</span><span class="o">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nx">piece</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">a</span><span class="o">:</span> <span class="nx">Couch</span> <span class="p">=&gt;</span> <span class="s2">&#34;Lie on the couch&#34;</span>
  <span class="k">case</span> <span class="nx">b</span><span class="o">:</span> <span class="nx">Chair</span> <span class="p">=&gt;</span> <span class="s2">&#34;Sit on the chair&#34;</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Pattern Matching</title>
			<link>https://ldipotetjob.github.io/posts/pattern_matching1-8/</link>
			<pubDate>Mon, 01 Jul 2019 11:36:33 +0800</pubDate>
			
			<guid>https://ldipotetjob.github.io/posts/pattern_matching1-8/</guid>
			<description>Some examples of patterns are:
 The pattern ex: IOException matches all instances of class IOException, binding variable ex to the instance. The pattern Some(x) matches values of the form Some(v), binding x to the argument value v of the Some constructor. The pattern (x, _) matches pairs of values, binding x to the first component of the pair. The second component is matched with a wildcard pattern. The pattern x :: y :: xs matches lists of length ≥2, binding x to the list&amp;rsquo;s first element, y to the list&amp;rsquo;s second element, and xs to the remainder.</description>
			<content type="html"><![CDATA[<p><a href="https://www.scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html">Some examples of patterns are:</a></p>
<ol>
<li>The pattern ex: IOException matches all instances of class  IOException, binding variable ex to the instance.</li>
<li>The pattern Some(x) matches values of the form Some(v), binding x to the argument value v of the Some constructor.</li>
<li>The pattern (x, _) matches pairs of values, binding x to the first component of the pair. The second component is matched with a wildcard pattern.</li>
<li>The pattern x :: y :: xs matches lists of length ≥2, binding x to the list&rsquo;s first element, y to the list&rsquo;s second element, and xs to the remainder.</li>
<li>The pattern 1 | 2 | 3 matches the integers between 1 and 3.</li>
</ol>
<hr>
<p><a href="https://www.scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html#variable-patterns">Variable Patterns:</a></p>
<blockquote>
<p>SimplePattern   ::=  ‘_’<br>
|  varid</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">import</span> <span class="nx">scala</span><span class="p">.</span><span class="nx">util</span><span class="p">.</span><span class="nx">Random</span>
<span class="nx">val</span> <span class="nx">x</span><span class="o">:</span> <span class="nx">Int</span> <span class="o">=</span> <span class="nx">Random</span><span class="p">.</span><span class="nx">nextInt</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="nx">x</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">0</span> <span class="p">=&gt;</span> <span class="s2">&#34;zero&#34;</span>
  <span class="k">case</span> <span class="mi">1</span> <span class="p">=&gt;</span> <span class="s2">&#34;one&#34;</span>
  <span class="k">case</span> <span class="mi">2</span> <span class="p">=&gt;</span> <span class="s2">&#34;two&#34;</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="s2">&#34;many&#34;</span>
<span class="p">}</span>
<span class="c1">// the result can be any value is a random function
</span><span class="c1"></span>
<span class="nx">def</span> <span class="nx">matchTest</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="nx">Int</span><span class="p">)</span><span class="o">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="nx">x</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">1</span> <span class="p">=&gt;</span> <span class="s2">&#34;one&#34;</span>
  <span class="k">case</span> <span class="mi">2</span> <span class="p">=&gt;</span> <span class="s2">&#34;two&#34;</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="s2">&#34;many&#34;</span>
<span class="p">}</span>
<span class="nx">matchTest</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1">//res1: String = many
</span><span class="c1"></span><span class="nx">matchTest</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">//res2: String = one
</span></code></pre></div><p><a href="https://www.scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html#typed-patterns">Typed Patterns:</a></p>
<blockquote>
<p>Pattern1        ::=  varid ‘:’ TypePat<br>
|  ‘_’ ‘:’ TypePat</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">val</span> <span class="nx">mystrType</span><span class="o">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="s2">&#34;String value for Pattern matching&#34;</span>

<span class="nx">mystrType</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">tmpstrValue</span><span class="o">:</span><span class="nb">String</span><span class="p">=&gt;</span><span class="nx">s</span><span class="s2">&#34;String value: $tmpstrValue&#34;</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="s2">&#34;Any other str value&#34;</span>
<span class="p">}</span>

<span class="nx">val</span> <span class="nx">testListType</span><span class="o">:</span><span class="nx">List</span><span class="p">[</span><span class="nx">Int</span><span class="p">]</span> <span class="o">=</span> <span class="nx">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>

<span class="nx">testListType</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">tmpListIntValue</span><span class="o">:</span><span class="nx">List</span><span class="p">[</span><span class="nx">Int</span><span class="p">]=&gt;</span> <span class="nx">s</span><span class="s2">&#34;List[Int] value: $tmpListIntValue&#34;</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="s2">&#34;No list[Int] Type&#34;</span>
<span class="p">}</span>

<span class="nx">testListType</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">tmpListgenericValue</span><span class="o">:</span><span class="nx">List</span><span class="p">[</span><span class="mi">_</span><span class="p">]=&gt;</span> <span class="nx">s</span><span class="s2">&#34;List[_] generic value: $tmpListgenericValue&#34;</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="s2">&#34;No list[Int] Type&#34;</span>
<span class="p">}</span>

<span class="c1">// mystrType: String = String value for Pattern matching
</span><span class="c1">// res3: String = String value: String value for Pattern matching
</span><span class="c1"></span>
</code></pre></div><p><a href="https://www.scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html#pattern-binders">Pattern Binders:</a></p>
<blockquote>
<p>Pattern2        ::=  varid ‘@’ Pattern3</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="cm">/**
</span><span class="cm">  *   
</span><span class="cm">  *   is very useful is the var tha you want to match can have different type of values and
</span><span class="cm">  *   at the same time you need to discriminate de type and process its values at the same time
</span><span class="cm">  *   A pattern binder x@p consists of a pattern variable x and a pattern p.
</span><span class="cm">  *   The type of the variable x is the static type T of the pattern p.
</span><span class="cm">  *   Is very important to KNOW that this pattern matches any value v matched by the pattern p, provided the
</span><span class="cm">  *   run-time type of v is also an instance of T, and it binds the variable name to that value.
</span><span class="cm">  *
</span><span class="cm">  */</span>

<span class="nx">val</span> <span class="nx">testListBinding</span><span class="o">:</span><span class="nx">List</span><span class="p">[</span><span class="nx">Int</span><span class="p">]</span> <span class="o">=</span> <span class="nx">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>

<span class="nx">testListBinding</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">testingList</span><span class="err">@</span><span class="nx">List</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">_</span><span class="o">*</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">s</span><span class="s2">&#34;list start with1, we&#39;re testing binging with this list:$testingList&#34;</span>
  <span class="k">case</span> <span class="nx">testingList</span><span class="err">@</span><span class="nx">List</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">_</span><span class="o">*</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">s</span><span class="s2">&#34;list start with3, we&#39;re testing binging with this list:$testingList&#34;</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="s2">&#34; nothing match  binding&#34;</span>
<span class="p">}</span>

<span class="c1">// testListBinding: List[Int] = List(1, 2, 3, 4)
</span><span class="c1">// res3: String = list start with1, we&#39;re testing binging with this list:List(1, 2, 3, 4)
</span><span class="c1"></span>
<span class="nx">val</span> <span class="nx">optBindingStrval</span><span class="o">:</span><span class="nb">String</span> <span class="o">=</span> <span class="s2">&#34;Testing scala specification&#34;</span>
<span class="nx">val</span> <span class="nx">optbinding</span><span class="o">:</span> <span class="nx">Option</span><span class="p">[</span><span class="nb">String</span><span class="p">]</span> <span class="o">=</span> <span class="nx">Some</span><span class="p">(</span><span class="nx">optBindingStrval</span><span class="p">)</span>

<span class="nx">optbinding</span> <span class="nx">match</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">optbinding</span><span class="err">@</span><span class="nx">Some</span><span class="p">(</span><span class="nx">optStrValue</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">optbinding</span><span class="p">.</span><span class="nx">getOrElse</span><span class="p">(</span><span class="s2">&#34;wrong value&#34;</span><span class="p">)</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span><span class="s2">&#34;no optStrValue&#34;</span>
<span class="p">}</span>

</code></pre></div><p><a href="https://www.scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html#literal-patterns">Literal Patterns:</a></p>
<blockquote>
<p>SimplePattern   ::=  StableId</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">val</span> <span class="nx">literalPattern</span><span class="o">:</span> <span class="nx">Any</span> <span class="o">=</span> <span class="kc">true</span>

<span class="nx">literalPattern</span> <span class="nx">match</span> <span class="p">{</span>

  <span class="k">case</span> <span class="mi">0</span> <span class="p">=&gt;</span> <span class="s2">&#34;zero&#34;</span>
  <span class="k">case</span> <span class="kc">true</span> <span class="p">=&gt;</span> <span class="s2">&#34;&#34;</span>

<span class="p">}</span>
</code></pre></div><p><a href="https://www.scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html#stable-identifier-patterns">Stable Identifier Patterns:</a></p>
<blockquote>
<p>SimplePattern   ::=  StableId</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">def</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="nx">Int</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">Int</span><span class="p">)</span> <span class="o">=</span> <span class="nx">x</span> <span class="nx">match</span> <span class="p">{</span>

  <span class="cm">/**
</span><span class="cm">    * in this case y =&gt; s&#34;$x and $y are equals&#34;
</span><span class="cm">    * the other cases are unreachable because always match with y
</span><span class="cm">    */</span>

  <span class="k">case</span> <span class="sb">`y`</span> <span class="p">=&gt;</span> <span class="nx">s</span><span class="s2">&#34;$x and $y are equals&#34;</span>
  <span class="k">case</span>  <span class="mi">_</span>  <span class="p">=&gt;</span> <span class="s2">&#34;x and y are not equals&#34;</span>
<span class="p">}</span>

<span class="nx">f</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="c1">// res9: String = 5 and 5 are equals
</span><span class="c1"></span>
<span class="nx">f</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span> <span class="c1">// res10: String = x and y are not equals
</span><span class="c1"></span>
<span class="nx">def</span> <span class="nx">mMatch</span><span class="p">(</span><span class="nx">s</span><span class="o">:</span> <span class="nb">String</span><span class="p">,</span><span class="nx">target</span><span class="o">:</span> <span class="nb">String</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">s</span> <span class="nx">match</span> <span class="p">{</span>
    <span class="k">case</span> <span class="sb">`target`</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="s2">&#34;It was &#34;</span> <span class="o">+</span> <span class="nx">target</span><span class="p">)</span>
    <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="s2">&#34;It was something else&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">mMatch</span><span class="p">(</span><span class="s2">&#34;a&#34;</span><span class="p">,</span><span class="s2">&#34;b&#34;</span><span class="p">)</span>  <span class="c1">// It was something else
</span><span class="c1"></span>
<span class="nx">def</span> <span class="nx">mMatchrefactored</span><span class="p">(</span><span class="nx">s</span><span class="o">:</span> <span class="nb">String</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">val</span> <span class="nx">target</span><span class="o">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="s2">&#34;a&#34;</span>
  <span class="nx">val</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">target</span>
  <span class="nx">s</span> <span class="nx">match</span> <span class="p">{</span>
    <span class="k">case</span> <span class="sb">`x`</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="s2">&#34;It was &#34;</span> <span class="o">+</span> <span class="nx">target</span><span class="p">)</span>
    <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="s2">&#34;It was something else&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">mMatchrefactored</span><span class="p">(</span><span class="s2">&#34;a&#34;</span><span class="p">)</span>

<span class="c1">// It was a
</span><span class="c1">// res12: Unit = ()
</span><span class="c1"></span>
</code></pre></div><p><a href="https://www.scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html#constructor-patterns">Constructor Patterns:</a></p>
<blockquote>
<p>SimplePattern   ::=  StableId ‘(’ [Patterns] ‘)’</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="cm">/**
</span><span class="cm">  * there are better implementations for these examples but the main idea is the explanation
</span><span class="cm">  * of this pattern as easy as possible
</span><span class="cm">  */</span>

<span class="k">case</span> <span class="kr">class</span> <span class="nx">Student</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span><span class="nb">String</span><span class="p">,</span><span class="nx">age</span><span class="o">:</span><span class="nx">Int</span><span class="p">,</span><span class="nx">birtdate</span><span class="o">:</span><span class="nb">String</span><span class="p">)</span>

<span class="k">case</span> <span class="kr">class</span> <span class="nx">Teacher</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span><span class="nb">String</span><span class="p">,</span><span class="nx">age</span><span class="o">:</span><span class="nx">Int</span><span class="p">,</span><span class="nx">birtdate</span><span class="o">:</span><span class="nb">String</span><span class="p">)</span>

<span class="nx">def</span> <span class="nx">studentOrTeacher</span><span class="p">(</span><span class="nx">person</span><span class="o">:</span> <span class="nx">Any</span><span class="p">)</span><span class="o">:</span> <span class="nx">Unit</span> <span class="o">=</span> <span class="p">{</span>

  <span class="nx">person</span> <span class="nx">match</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">person</span><span class="err">@</span><span class="nx">Student</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">age</span><span class="p">,</span><span class="nx">birthdate</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="nx">s</span><span class="s2">&#34;the Student:$name is $age old and born $birthdate &#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">person</span><span class="err">@</span><span class="nx">Teacher</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">age</span><span class="p">,</span><span class="nx">birthdate</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="nx">s</span><span class="s2">&#34;the Teacher:$name is $age old and born $birthdate &#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="mi">_</span>  <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="s2">&#34;Could be any one, No teacher or Person&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">studentOrTeacher</span><span class="p">(</span><span class="nx">Student</span><span class="p">(</span><span class="s2">&#34;Jose Luis&#34;</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="s2">&#34;28 feb 1971&#34;</span><span class="p">))</span>

<span class="c1">//the Student:Jose Luis is 18 and born 28 feb 1971
</span><span class="c1">// res13: Unit = ()
</span><span class="c1"></span>

<span class="nx">def</span> <span class="nx">studentOrTeacherVer1</span><span class="p">(</span><span class="nx">person</span><span class="o">:</span> <span class="nx">Any</span><span class="p">)</span><span class="o">:</span> <span class="nx">Unit</span> <span class="o">=</span> <span class="p">{</span>

  <span class="nx">person</span> <span class="nx">match</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">Student</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">age</span><span class="p">,</span><span class="nx">birthdate</span><span class="p">)=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="nx">s</span><span class="s2">&#34;the Student:$name is $age old and born $person.birthdate &#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">Teacher</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">age</span><span class="p">,</span><span class="nx">birthdate</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="nx">s</span><span class="s2">&#34;the Teacher:$name is $age old and born $birthdate &#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="mi">_</span>  <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="s2">&#34;Could be any one, No teacher or Person&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">studentOrTeacher</span><span class="p">(</span><span class="nx">Teacher</span><span class="p">(</span><span class="s2">&#34;Jose Luis&#34;</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="s2">&#34;28 feb 1971&#34;</span><span class="p">))</span>
<span class="nx">Teacher</span><span class="p">.</span><span class="nx">unapply</span><span class="p">(</span><span class="nx">Teacher</span><span class="p">(</span><span class="s2">&#34;Jose Luis&#34;</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="s2">&#34;28 feb 1971&#34;</span><span class="p">))</span>

<span class="c1">//the Teacher:Jose Luis is 18 old and born 28 feb 1971
</span><span class="c1">//res14: Unit = ()
</span><span class="c1"></span>
</code></pre></div><p><a href="https://www.scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html#tuple-patterns">Tuple Patterns:</a></p>
<blockquote>
<p>SimplePattern   ::=  ‘(’ [Patterns] ‘)’</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript">
<span class="cm">/**
</span><span class="cm">  * For this specification you&#39;ll need to know what is Tuple in scala.
</span><span class="cm">  * If you don&#39;t know We recommend this link: https://docs.scala-lang.org/tour/tuples.html
</span><span class="cm">  *
</span><span class="cm"> */</span>

<span class="nx">val</span> <span class="nx">ingredient</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&#34;Sugar&#34;</span> <span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
<span class="nx">val</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">quantity</span><span class="p">)</span> <span class="o">=</span> <span class="nx">ingredient</span>
<span class="nx">val</span> <span class="nx">fruit</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&#34;orange&#34;</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="s2">&#34;spain&#34;</span><span class="p">)</span>
<span class="nx">val</span> <span class="p">(</span><span class="nx">namefruit</span><span class="p">,</span> <span class="nx">amount</span><span class="p">,</span><span class="nx">origin</span><span class="p">)</span> <span class="o">=</span> <span class="nx">fruit</span>

<span class="nx">def</span> <span class="nx">anyObject</span><span class="p">(</span><span class="nx">param</span><span class="o">:</span><span class="nx">Any</span><span class="p">)</span><span class="o">:</span> <span class="nx">Unit</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">param</span>  <span class="nx">match</span> <span class="p">{</span>
    <span class="k">case</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">amount</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="nx">s</span><span class="s2">&#34;we are talking about the ingredients:$name&#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">amount</span><span class="p">,</span><span class="nx">origin</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="nx">s</span><span class="s2">&#34;we are talking about the fruits:$name&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">anyObject</span><span class="p">(</span><span class="nx">fruit</span><span class="p">)</span>
<span class="c1">// we are talking about the fruits:orange
</span><span class="c1">// res15: Unit = ()
</span><span class="c1"></span>
<span class="nx">anyObject</span><span class="p">(</span><span class="nx">ingredient</span><span class="p">)</span>

<span class="c1">//we are talking about the ingredients:Sugar
</span><span class="c1">//res16: Unit = ()
</span><span class="c1"></span>
</code></pre></div><p><a href="https://www.scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html#extractor-patterns">Extractor Patterns:</a></p>
<blockquote>
<p>SimplePattern   ::=  StableId ‘(’ [Patterns] ‘)’</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">// For a better understanding of this pattern I recommend to read the following next link:
</span><span class="c1">// https://docs.scala-lang.org/tour/extractor-objects.html
</span><span class="c1"></span>
<span class="k">case</span> <span class="kr">class</span> <span class="nx">StudentVer</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span><span class="nb">String</span><span class="p">,</span><span class="nx">age</span><span class="o">:</span><span class="nx">Int</span><span class="p">,</span><span class="nx">birtdate</span><span class="o">:</span><span class="nb">String</span><span class="p">)</span>

<span class="c1">// Internally what&#39;s going on? :
</span><span class="c1"></span>
<span class="nx">object</span> <span class="nx">StudentVer</span><span class="p">{</span>
  <span class="nx">def</span> <span class="nx">apply</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span><span class="nb">String</span><span class="p">,</span><span class="nx">age</span><span class="o">:</span><span class="nx">Int</span><span class="p">,</span><span class="nx">birtdate</span><span class="o">:</span><span class="nb">String</span><span class="p">)</span><span class="o">:</span> <span class="nx">StudentVer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">StudentVer</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">age</span><span class="p">,</span><span class="nx">birtdate</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// when create en new case class
</span><span class="c1"></span><span class="nx">val</span> <span class="nx">myFirstStudentVer</span><span class="o">:</span><span class="nx">StudentVer</span> <span class="o">=</span> <span class="nx">StudentVer</span><span class="p">(</span><span class="s2">&#34;Craig Page&#34;</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="s2">&#34;20 August,1999&#34;</span><span class="p">)</span>

<span class="c1">// Internally, it is calling the apply method of StudentVer1 companion object to create new StudentVer1 object:
</span><span class="c1"></span>
<span class="nx">val</span> <span class="nx">myFirstStudentVer1</span> <span class="o">=</span> <span class="nx">StudentVer</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="s2">&#34;Craig Page&#34;</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="s2">&#34;20 August,1999&#34;</span><span class="p">)</span>

<span class="c1">// The reverse operation to Apply could be the case in which we have the case class value and we want to
</span><span class="c1">// know its values
</span><span class="c1"></span>
<span class="nx">val</span> <span class="nx">mytuplaOfUnapply</span> <span class="o">=</span> <span class="nx">StudentVer</span><span class="p">.</span><span class="nx">unapply</span><span class="p">(</span><span class="nx">myFirstStudentVer1</span><span class="p">)</span>

<span class="c1">//val (namestudent,age,brithdate) = StudentVer.unapply(myFirstStudentVer1)
</span><span class="c1"></span>
<span class="nx">mytuplaOfUnapply</span> <span class="nx">match</span> <span class="p">{</span>

  <span class="k">case</span> <span class="nx">Some</span><span class="p">((</span><span class="nx">namestudent</span><span class="p">,</span><span class="nx">age</span><span class="p">,</span><span class="nx">brithdate</span><span class="p">))</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="nx">s</span><span class="s2">&#34;Testing extractor name:$namestudent,age:$age,birthdate:$brithdate&#34;</span><span class="p">)</span>
  <span class="k">case</span> <span class="mi">_</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="s2">&#34;nothing to show&#34;</span><span class="p">)</span>

<span class="p">}</span>

<span class="nx">val</span> <span class="nx">StudentVer</span><span class="p">(</span><span class="nx">nameStudentVer</span><span class="p">,</span><span class="nx">ageStudentVer</span><span class="p">,</span><span class="nx">birtdateStudentVer</span><span class="p">)</span> <span class="o">=</span> <span class="nx">myFirstStudentVer1</span>

<span class="nx">println</span><span class="p">(</span><span class="nx">s</span><span class="s2">&#34;Another example testing extractor name:$nameStudentVer,age:$ageStudentVer,birthdate:$ageStudentVer&#34;</span><span class="p">)</span>

<span class="nx">def</span> <span class="nx">studentOrTeacherUsingExtractors</span><span class="p">(</span><span class="nx">person</span><span class="o">:</span> <span class="nx">Any</span><span class="p">)</span><span class="o">:</span> <span class="nx">Unit</span> <span class="o">=</span> <span class="p">{</span>

  <span class="c1">//Pattern matching is using extractors in this point
</span><span class="c1"></span>  <span class="nx">person</span> <span class="nx">match</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">Student</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">age</span><span class="p">,</span><span class="nx">birthdate</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="nx">s</span><span class="s2">&#34;the Student:$name is $age old and born $birthdate &#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">Teacher</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">age</span><span class="p">,</span><span class="nx">birthdate</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="nx">s</span><span class="s2">&#34;the Teacher:$name is $age old and born $birthdate &#34;</span><span class="p">)</span>
    <span class="k">case</span> <span class="mi">_</span>  <span class="p">=&gt;</span> <span class="nx">println</span><span class="p">(</span><span class="s2">&#34;Could be any one, No teacher or Person&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

</code></pre></div>]]></content>
		</item>
		
	</channel>
</rss>
